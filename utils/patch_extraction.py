import os
from tqdm import tqdm
import numpy as np
import pandas as pd
from PIL import Image
import openslide


def load_images(slide_path, mask_path):
    image = np.array(Image.open(slide_path))
    mask = np.array(Image.open(mask_path))
    mask = np.asarray(mask)[:,:,0]>0
    mask = mask.astype(bool)
    return image, mask

def load_images_openslide(slide_path, mask_path):
    image = openslide.OpenSlide(slide_path)
    image = image.read_region((0, 0), 0, image.level_dimensions[0]).convert('RGB')
    image = np.asarray(image)
    mask = openslide.OpenSlide(mask_path)
    mask = mask.read_region((0, 0), 0, mask.level_dimensions[0]).convert('RGB')
    mask = np.asarray(mask)[:,:,0]>0
    mask = mask.astype(bool)
    return image, mask


def generate_coordinates(image_shape, patch_shape, overlap):
    '''
    Generates coordinate grid for a whole slide image (WSI) .

    image_shape (tuple): shape of the image
    patch_shape (tuple): desired shape of the patches
    overlap (float): percentage of overlap between patches (0-1) 
    '''

    patch_shape = (patch_shape, patch_shape)
    # Define stride depending on the overlap
    stride = (patch_shape[0]*(1-overlap), patch_shape[1]*(1-overlap))
    # Define maximum image size
    xmax = image_shape[0] - patch_shape[0] 
    ymax = image_shape[1] - patch_shape[1]
    # Initialize coords
    coords=[]
    # Define grid for extracting patches
    step = np.ceil(np.divide(image_shape,stride)).astype(np.uint32)
    x = np.ceil(np.linspace(0, xmax, step[0])).astype(np.uint32)
    y = np.ceil(np.linspace(0, ymax, step[1])).astype(np.uint32)
    # Iterate through the grid
    for i in range(x.size):
            for j in range(y.size):
                    xs = x[i]
                    xe = xs + patch_shape[0]

                    ys = y[j]
                    ye = ys + patch_shape[1]
                    coords.append([xs, xe, ys, ye])
    return coords



def save_patches(coords, mask_th, image, mask, save_dir):
    '''
    Saves patches defined by the generated grid of coordinates

    coords (list): coordinate grid generated by generate_coordinates()
    mask_th (float): minimum percentage of mask to accept a patch (0-1)
    image (np.array): image from which to extract patches
    mask (boolean): tissue mask of the regions of interest
    save_dir (str): path to patch saving directory 
    white_out (bool): set the part of the patches that do not include the 
                      mask or are already selected to 255

    '''
    # Create the saving directory
    os.makedirs(save_dir, exist_ok=True)
    # Define patch_shape from the coords
    patch_shape = (coords[0][1]-coords[0][0], coords[0][3]-coords[0][2])
    pos_x = []
    pos_y = []
    print('Saving patches...')
    for i, indices in enumerate(tqdm(coords)):
            mask_patch = mask[indices[0]:indices[1], indices[2]:indices[3]]
            # Check if the mask covers at least mask_th of the patch
            if np.mean(mask_patch) > mask_th:
                patch = image[indices[0]:indices[1], indices[2]:indices[3], :]
                patch = Image.fromarray(patch).convert('RGB') 
                pos_x = np.append(pos_x, (indices[0] + patch_shape[0]/2))
                pos_y = np.append(pos_y, (indices[2] + patch_shape[1]/2))
                patch.save(os.path.join(
                    save_dir,'y'+str(int(indices[0] + patch_shape[0]/2))+'_x'+str(int(indices[2] + patch_shape[1]/2))+'.tif')
                    )
                pd.DataFrame(np.array([pos_y, pos_x]).transpose(), 
                             columns=['x','y']).to_csv(os.path.join(save_dir,'coords.csv'))


def yield_patches(coords, mask_th, image, mask, save_dir):
    '''
    Saves patches defined by the generated grid of coordinates

    coords (list): coordinate grid generated by generate_coordinates()
    mask_th (float): minimum percentage of mask to accept a patch (0-1)
    image (np.array): image from which to extract patches
    mask (boolean): tissue mask of the regions of interest
    save_dir (str): path to patch saving directory 
    white_out (bool): set the part of the patches that do not include the 
                      mask or are already selected to 255

    '''
    # Create the saving directory
    os.makedirs(save_dir, exist_ok=True)
    # Define patch_shape from the coords
    patch_shape = (coords[0][1]-coords[0][0], coords[0][3]-coords[0][2])
    pos_x = []
    pos_y = []
    for i, indices in enumerate(tqdm(coords)):
            mask_patch = mask[indices[0]:indices[1], indices[2]:indices[3]]
            # Check if the mask covers at least mask_th of the patch
            if np.mean(mask_patch) > mask_th:
                patch = image[indices[0]:indices[1], indices[2]:indices[3], :]
                patch = Image.fromarray(patch).convert('RGB') 
                pos_x = np.append(pos_x, (indices[0] + patch_shape[0]/2))
                pos_y = np.append(pos_y, (indices[2] + patch_shape[1]/2))
                pd.DataFrame(np.array([pos_y, pos_x]).transpose(), 
                             columns=['x','y']).to_csv(os.path.join(save_dir,'coords.csv'))
                yield patch
